## 架构

### 大概的架构

客户端

连接器(处理客户端连接)
分析器(词法分析，语法分析)
优化器(执行前的优化例如索引的选择)
执行器(执行 SQL，调用存储引擎返回结果)

存储引擎（InnoDB， MyISAM）

### 日志模块

#### redo log

#### binlog

#### 对比

1. redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。
2. redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。
3. redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志

#### 如何保证两个日志同步 ?

两阶段提交

## 事务

1. 务的特性：原子性、一致性、隔离性、持久性
2. 多事务同时执行的时候，可能会出现的问题：脏读、不可重复读、幻读
3. 事务隔离级别：读未提交、读提交、可重复读、串行化
4. 不同事务隔离级别的区别：

- 读未提交：一个事务还未提交，它所做的变更就可以被别的事务看到
- 读提交：一个事务提交之后，它所做的变更才可以被别的事务看到
- 可重复读：一个事务执行过程中看到的数据是一致的。未提交的更改对其-他事务是不可见的
- 串行化：对应一个记录会加读写锁，出现冲突的时候，后访问的事务必须等前一个事务执行完成才能继续执行

5. 配置方法：启动参数 transaction-isolation
6. 事务隔离的实现：每条记录在更新的时候都会同时记录一条回滚操作。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。
7. 回滚日志什么时候删除？系统会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。
8. 什么时候不需要了？当系统里么有比这个回滚日志更早的 read-view 的时候。
9. 为什么尽量不要使用长事务。长事务意味着系统里面会存在很老的事务视图，在这个事务提交之前，回滚记录都要保留，这会导致大量占用存储空间。除此之外，长事务还占用锁资源，可能会拖垮库。
10. 事务启动方式：一、显式启动事务语句，begin 或者 start transaction,提交 commit，回滚 rollback；二、set autocommit=0，该命令会把这个线程的自动提交关掉。这样只要执行一个 select 语句，事务就启动，并不会自动提交，直到主动执行 commit 或 rollback 或断开连接。
11. 建议使用方法一，如果考虑多一次交互问题，可以使用 commit work and chain 语法。在 autocommit=1 的情况下用 begin 显式启动事务，如果执行 commit 则提交事务。如果执行 commit work and chain 则提交事务并自动启动下一个事务。
